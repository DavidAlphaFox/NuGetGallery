// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Threading.Tasks;
using NuGet.Services.Entities;
using NuGet.Versioning;

namespace NuGetGallery
{
    public class PackageVulnerabilityService : IPackageVulnerabilityService
    {
        public PackageVulnerabilityService(
            IEntitiesContext entitiesContext,
            IPackageUpdateService packageUpdateService)
        {
            _entitiesContext = entitiesContext ?? throw new ArgumentNullException(nameof(entitiesContext));
            _packageUpdateService = packageUpdateService ?? throw new ArgumentNullException(nameof(packageUpdateService));
        }

        private readonly IEntitiesContext _entitiesContext;
        private readonly IPackageUpdateService _packageUpdateService;

        public async Task UpdateVulnerabilityAsync(PackageVulnerability vulnerability, bool wasWithdrawn)
        {
            if (vulnerability == null)
            {
                throw new ArgumentNullException(nameof(vulnerability));
            }

            using (var strategy = new SuspendDbExecutionStrategy())
            using (var transaction = _entitiesContext.GetDatabase().BeginTransaction())
            {
                var packagesToUpdate = new HashSet<Package>();
                UpdateVulnerabilityInternal(vulnerability, wasWithdrawn, packagesToUpdate);
                await _entitiesContext.SaveChangesAsync();

                if (packagesToUpdate.Any())
                {
                    await _packageUpdateService.UpdatePackagesAsync(packagesToUpdate.ToList());
                }

                transaction.Commit();
            }
        }

        /// <summary>
        /// Updates the database with <paramref name="vulnerability"/>.
        /// </summary>
        /// <param name="vulnerability">The <see cref="PackageVulnerability"/> to persist in the database.</param>
        /// <param name="wasWithdrawn">Whether or not this vulnerability has been withdrawn.</param>
        /// <param name="packagesToUpdate">The set of <see cref="Package"/>s affected by this operation that should be marked as updated.</param>
        /// <returns>
        /// If the vulnerability already exists, returns the existing vulnerability.
        /// If the vulnerability does not already exist, returns <paramref name="vulnerability"/>.
        /// </returns>
        private void UpdateVulnerabilityInternal(PackageVulnerability vulnerability, bool wasWithdrawn, HashSet<Package> packagesToUpdate)
        {
            if (vulnerability == null)
            {
                throw new ArgumentNullException(nameof(vulnerability));
            }

            // Determine if we already have this vulnerability.
            var existingVulnerability = _entitiesContext.Vulnerabilities
                .Include(v => v.AffectedRanges)
                .Include(v => v.AffectedRanges.Select(pv => pv.Packages))
                .SingleOrDefault(v => v.GitHubDatabaseKey == vulnerability.GitHubDatabaseKey);

            var rangeComparer = new RangeForSameVulnerabilityEqualityComparer();
            if (existingVulnerability == null)
            {
                // We do not yet have this vulnerability. We should add it if it is not withdrawn and could affect at least one package.
                // If the vulnerability does not have any vulnerable ranges, it cannot affect any packages.
                // Even if no packages are currently vulnerable to the vulnerability, as long as it has a vulnerable range, 
                // there is at least one package that could be uploaded that would be vulnerable to it.
                if (!wasWithdrawn && vulnerability.AffectedRanges.Any())
                {
                    _entitiesContext.Vulnerabilities.Add(vulnerability);
                    _entitiesContext.VulnerableRanges.AddRange(vulnerability.AffectedRanges);
                    foreach (var newRange in vulnerability.AffectedRanges)
                    {
                        ProcessNewVulnerabilityRange(newRange, packagesToUpdate);
                    }
                }
            }
            else
            {
                // We already have this vulnerability, so we should update it.
                var vulnerablePackages = existingVulnerability.AffectedRanges.SelectMany(pv => pv.Packages);
                // If the vulnerability was withdrawn or lost all its ranges, all packages marked vulnerable need to be unmarked and updated.
                if (wasWithdrawn || !vulnerability.AffectedRanges.Any())
                {
                    packagesToUpdate.UnionWith(vulnerablePackages);
                    _entitiesContext.Vulnerabilities.Remove(existingVulnerability);
                    _entitiesContext.VulnerableRanges.RemoveRange(existingVulnerability.AffectedRanges);
                }
                else
                {
                    // Update the vulnerability's metadata.
                    var wasUpdated = false;
                    if (vulnerability.Severity != existingVulnerability.Severity)
                    {
                        existingVulnerability.Severity = vulnerability.Severity;
                        wasUpdated = true;
                    }

                    if (vulnerability.ReferenceUrl != existingVulnerability.ReferenceUrl)
                    {
                        existingVulnerability.ReferenceUrl = vulnerability.ReferenceUrl;
                        wasUpdated = true;
                    }

                    if (wasUpdated)
                    {
                        // If the vulnerability's metadata was updated, all packages marked vulnerable need to be updated.
                        packagesToUpdate.UnionWith(vulnerablePackages);
                    }

                    // Any new ranges in this vulnerability need to be added to the database.
                    var newRanges = vulnerability.AffectedRanges
                        .Except(existingVulnerability.AffectedRanges, rangeComparer)
                        .ToList();
                    _entitiesContext.VulnerableRanges.AddRange(newRanges);
                    foreach (var newRange in newRanges)
                    {
                        newRange.Vulnerability = existingVulnerability;
                        existingVulnerability.AffectedRanges.Add(newRange);
                        ProcessNewVulnerabilityRange(newRange, packagesToUpdate);
                    }

                    // Any ranges that are missing from this vulnerability need to be removed.
                    var missingRanges = existingVulnerability.AffectedRanges
                        .Except(vulnerability.AffectedRanges, rangeComparer)
                        .ToList();
                    _entitiesContext.VulnerableRanges.RemoveRange(missingRanges);
                    foreach (var missingRange in missingRanges)
                    {
                        existingVulnerability.AffectedRanges.Remove(missingRange);
                        packagesToUpdate.UnionWith(missingRange.Packages);
                    }
                }
            }
        }

        /// <summary>
        /// Iterates through the <see cref="Package"/>s that could be vulnerable to <paramref name="range"/>.
        /// If any of these packages have not been marked vulnerable and should be, mark them vulnerable and add them to <paramref name="packagesToUpdate"/>.
        /// </summary>
        /// <remarks>
        /// It is not possible to query the database to only return packages satisfying the version range, so we must iterate through all <see cref="Package"/>s in the <see cref="PackageRegistration"/>.
        /// </remarks>
        private void ProcessNewVulnerabilityRange(VulnerablePackageVersionRange range, HashSet<Package> packagesToUpdate)
        {
            var versionRange = VersionRange.Parse(range.PackageVersionRange);
            var packages = _entitiesContext.PackageRegistrations
                .Where(pr => pr.Id == range.PackageId)
                .SelectMany(pr => pr.Packages)
                .ToList();

            foreach (var package in packages)
            {
                var version = NuGetVersion.Parse(package.NormalizedVersion);
                var satisfiesVersionRange = versionRange.Satisfies(version);
                if (satisfiesVersionRange)
                {
                    package.Vulnerabilities.Add(range);
                    range.Packages.Add(package);
                    packagesToUpdate.Add(package);
                }
            }
        }

        /// <remarks>
        /// A <see cref="VulnerablePackageVersionRange"/> is equal to another <see cref="VulnerablePackageVersionRange"/> if it has the same
        /// <see cref="PackageVulnerability"/>, <see cref="VulnerablePackageVersionRange.PackageId"/>, and <see cref="VulnerablePackageVersionRange.PackageVersionRange"/>.
        /// We have determined that the <see cref="PackageVulnerability"/> is the same already, so no need to compare it.
        /// </remarks>
        private class RangeForSameVulnerabilityEqualityComparer : IEqualityComparer<VulnerablePackageVersionRange>
        {
            public bool Equals(VulnerablePackageVersionRange x, VulnerablePackageVersionRange y)
            {
                return x?.PackageId == y?.PackageId
                    && x?.PackageVersionRange == y?.PackageVersionRange;
            }

            public int GetHashCode(VulnerablePackageVersionRange obj)
            {
                return Tuple
                    .Create(
                        obj?.PackageId,
                        obj?.PackageVersionRange)
                    .GetHashCode();
            }
        }
    }
}